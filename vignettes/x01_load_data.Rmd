---
title: "01: Reading in the bedgraph data"
author: "Andrew Lindsay, Reka Toth"
date: "`r Sys.Date()`"
output: 
  html_document:
  toc: true
toc_depth: 3
toc_float: true
self_contained: yes
highlight: pygments
vignette: >
  %\VignetteIndexEntry{01: Reading in the bedgraph data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r message=FALSE, warning=FALSE, eval=F}
#Load library
library(scMethrix)
```

# Download the data {download}

The example data analysis presented here uses the following publicly available whole genome bisulfite sequencing data from GEO:
  [GSE56879](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE56879) 
  
Smallwood SA, Lee HJ, Angermueller C, Krueger F et al. Single-cell genome-wide bisulfite sequencing for assessing epigenetic heterogeneity. Nat Methods 2014 Aug;11(8):817-820. [PMID: 25042786](https://pubmed.ncbi.nlm.nih.gov/25042786/)

In this dataset, mouse embryonic stem cells (ESCs) have been grown in either serum or 2i medium. 2i medium is know to prevent differentiation of ESCs as well as induce [global hypomethylation](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5425728/), so the methylome should show drastic differences. In this example, 14 samples will be taken; half grown in 2i, and the rest in serum.

The data can be directly downloaded from GEO, using the `GEOquery` package. The files will be downloaded into the working directory. 

```{r message=FALSE, warning=FALSE, eval=F}
if(!requireNamespace("GEOquery")) {
  BiocManager::install("GEOquery")
}
library(GEOquery)  
```

```{r message=FALSE, warning=FALSE, eval=F}
data_dir = paste0(tempdir(),"/GSE56879/")
dir.create(path = data_dir, showWarnings = FALSE, recursive = TRUE)
```

```{r eval=F}

gsm_list <- c("GSM1370535","GSM1370536","GSM1370537","GSM1370538","GSM1370539","GSM1370540","GSM1370541","GSM1370555","GSM1370556","GSM1370557","GSM1370558","GSM1370559","GSM1370560","GSM1370561")

lapply(gsm_list, function(gsm){
  file <- GEOquery::getGEOSuppFiles(GEO = gsm, baseDir = data_dir, makeDirectory = FALSE, filter_regex = ".*.cov.txt.gz")
})

bed_files <- list.files(path = data_dir,  full.names = TRUE)
file.rename(bed_files,gsub("(.*GSM.*?)_.*","\\1.gz",bed_files))
bed_files <- list.files(path = data_dir,  full.names = TRUE)

print(basename(bed_files))
```

Please note: The sample name is generated from the input file name minus the extension (e.g,. `GSM1370535.bed` becomes `GSM1370535`, see [get_sample_name()](https://compepigen.github.io/scMethrix/reference/get_sample_name.html). As `data.table::fread` is used, ["Compressed files with extension .gz and .bz2 are supported if the R.utils package is installed"](https://www.rdocumentation.org/packages/data.table/versions/1.14.2/topics/fread). The ".gz" and ".bz2" extension will be droppe automatically.

# Processing

## CpG annotation 
As a first step, we need a list of CpG sites in the respective genome. The CpG sites are listed using the respective [BSgenome](https://bioconductor.org/packages/release/bioc/html/BSgenome.html) annotation package. The `read_beds` function is also able to extract CpG sites on it's own, however, it might be beneficial to do it separately. 

```{r message=FALSE, warning=FALSE, eval=F}
#Genome of your preference to work with
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
library(BiocManager)
if(!requireNamespace("BSgenome.Mmusculus.UCSC.mm10")) {
  BiocManager::install("BSgenome.Mmusculus.UCSC.mm10")
}
library(BSgenome.Mmusculus.UCSC.mm10) 
```

```{r, ref_data, eval=F}
mm10_cpgs <- suppressWarnings(scmMethrix::extract_CpGs(ref_genome = "BSgenome.Mmusculus.UCSC.mm10"))
head(mm10_cpgs)
```

## Sample annotation 
An annotation table is also necessary to perform some analyses. The data will be added to the `scMethrix` object in the `colData` slot. Each row of the table represents a single sample. Sample names are taken from the input file names, and stored as row.names. Subsequent information about each sample (e.g., cell type, alternate IDs, sample source, etc) are stored as columns within this `data.frame`. To access this data, see [Saving experiment metadata].

For inputted colData, the row name must match the corresponding sample name. See [Download the data](#download) for how sample names are generated. The row order of the inputted colData is not important as it will be added as a `merge(all.x=T)` (left join) to the sample names. Hence, the inputted colData can contain samples that are not present in the inputted files, and their respective colData will not be included in the experiment.

For this example, the desired colData can be easily extracted from the experiment's [SOFT file in GEO](https://ftp.ncbi.nlm.nih.gov/geo/series/GSE56nnn/GSE56879/soft/).

```{r, colData, eval=F}

soft <- GEOquery::getGEOfile("GSE56879")
soft <- GEOquery::getGEO(filename=soft)

GSE_colData <- sapply(names(soft@gsms), function(gsm) {
  soft@gsms[[gsm]]@header$title
})

GSE_colData <- gsub("_.*","",GSE_colData)
GSE_colData <- GSE_colData[which(names(soft@gsms) %in% gsm_list)]
GSE_colData <- data.frame(row.names = names(GSE_colData), Medium = GSE_colData)

GSE_colData
```

## Reading bedGraph files
`read_beds` function is a versatile bedgraph reader intended to import bedgraph files generated virtually by any sort of methylation calling program. It requires user to provide indices for chromosome names, start position and other required fields. There are also presets available to import `bedgraphs` from most common programs such as `Bismark` (.cov format), `MethylDackel`, and `MethylcTools`. In this case, there is no need to define e.g. `chr_idx` `start_idx` arguments, the function will automatically assign them. 
To know the exact parameters, it might worth to take a look at one of the files, to see the column order. 

```{r, eval=F}
res <- data.table::fread(bed_files[1])
colnames(res) <- c("chr","start","end","beta","M","U")
head(res)
```

The `read_beds` function adds CpGs missing from the reference set, and creates a methylation/coverage matrices. Once the process is complete, it returns an object of class `scMethrix`, which extends `SingleCellExperiment` class. `scMethrix` objects contain ‘methylation’ and (optionally) ‘coverage’ matrices (either in-memory or as on-disk HDF5 arrays) along with phenotype data and other basic info. This object can be passed to all downstream functions for various analysis. For further details on the data structure, see the `SingleCellExperiment` package: [SingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html)

* For computers with large memory, increase speed using `batch_size` parameter. This will open multiple files at once, but keep in mind that increasing the batch size will increase the memory needs as well. 

A more detailed description of the `read_beds` function is here: [read_beds](https://compepigen.github.io/WGBS_best_practice/read_bedgraphs.html))

```{r, read_beds, eval=F}
scm <- scMethrix::read_beds(
  files = bed_files,
  ref_cpgs = mm10_cpgs,
  chr_idx = 1,
  start_idx = 2,
  end_idx = 3,
  beta_idx = 4,
  M_idx = 5,
  U_idx = 6,
  stranded = FALSE,
  zero_based = FALSE, 
  colData = GSE_colData
)
```

Certain operations will cause metadata to be destroyed. For range metadata, `bin_scMethrix()` will discard row metadata (except for CpG count), as will `collapse_samples` for sample metadata (except for sample names). It is advised to extract this data from `rowData()` and `colData()`, respectively, and store it within `metadata()` instead.

**Potential pitfalls: **
Too many missing CpGs, if not expected, might indicate that something went wrong. 

* An obvious error is using the wrong reference genome. 

* A common mistake is falsely indicating strandedness and zero or one based positioning. The combination of the two might lead to only using C-s from one strand (due to a 1 bp shift), resulting lower coverage for the sites. A nice description of the zero- and one-based coordination system can be found [here](http://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/) 

## Extracting assay matricies

After the experiment is created, an assay matrix can be generated.  The methylation and coverage matrices can be directly obtained with the functions `score()` and `counts()`, respectively, while any matrix can be accessed via `get_matrix(scm, assay="ASSAY_NAME")`.

```{r eval=F}
mtx <- get_matrix(scm, assay="score")
head(mtx)
```
Genomic loci can also be added (`add_loci`), be formatted as a `GenomicRanges` object, and ordered by variance (`order_by_sd`), if desired.

```{r eval=F}
# Add genomic loci, put in a GRanges object, and order by SD
mtx <- get_matrix(scm, assay="score", add_loci = TRUE, in_granges=TRUE, order_by_sd = TRUE)
head(mtx)
```

## Saving experiment metadata

scMethrix can store experiment metadata. Depending on the type of data, it is stored in different places:

1. Experiment-wide metadata: General information is stored in metadata() as a named `list`. This can be information like genome accession, GEO IDs, authors, or any other information that needs just a single variable.

```{r eval=F}
metadata(scm)
```

2. Range metadata: Information about ranges is stored as a `data.frame` in rowData(). This is stored within the rowRanges() sub-object inside the `scMethrix` object.  

```{r eval=F}
rowData(scm)
```

3. Sample metadata: Information about samples is stored as a `data.frame` in colData(). This can include alternate samples IDs, run IDs, tissue types, or anything associated with individual samples. In this example, only the medium used for growing each sample is stored.

```{r eval=F}
colData(scm)
```

